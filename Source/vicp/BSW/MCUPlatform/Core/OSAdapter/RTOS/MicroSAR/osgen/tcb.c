/* file: D:/AutoSar generated code/tcb.c */
/* automatically generated by genRH850.exe, Version: 1.06 */
/* Configuration file: D:/PROJECT/VICP/OIL/GHS PROJECT/OIL_CFG/NOEVENT_ISR_TAUB0I0_WDTA0.oil */
/* Generation time: Fri May 06 17:42:39 2016 */
/* Unlimited license CBD1500834 for Huizhou Desay SV Automotive, Product License, Instrument Panel */
/* Implementation: RH850_D1M */
/* Version of general code: 9.01.04 */
#if defined USE_QUOTE_INCLUDES
 #include "vrm.h"
#else
 #include <vrm.h>
#endif

#define osdVrmGenMajRelNum 1
#define osdVrmGenMinRelNum 6
#if defined USE_QUOTE_INCLUDES
 #include "vrm.h"
#else
 #include <vrm.h>
#endif

#if defined USE_QUOTE_INCLUDES
 #include "Os.h"
#else
 #include <Os.h>
#endif

#if defined USE_QUOTE_INCLUDES
 #include "osekext.h"
#else
 #include <osekext.h>
#endif

#pragma ghs section bss=".os_bss"
#pragma ghs section data=".os_data"
#pragma ghs section sbss=".os_sbss"
#pragma ghs section sdata=".os_sdata"
#pragma ghs section text=".os_text"
#pragma ghs section rodata=".os_rodata"
#pragma ghs section rosdata=".os_rosdata"



/*--------------------------------------------------------------------------*/
/*    alarms                                                                */
/*--------------------------------------------------------------------------*/
   #if (osdNumberOfAlarms+osdNumberOfScheduleTables>0)
      osqTcbRAM1 volatile osqTcbRAM2 TickType osqTcbRAM3 osAlarmTime[osdNumberOfAlarms+osdNumberOfScheduleTables];
   #else
      osqTcbRAM1 volatile osqTcbRAM2 TickType osqTcbRAM3 osAlarmTime[1];
   #endif
   #if (osdNumberOfAlarms>0)
      osqTcbRAM1 volatile osqTcbRAM2 osuint8 osqTcbRAM3 osAlarmActivated[osdNumberOfAlarms];
   #else
      osqTcbRAM1 volatile osqTcbRAM2 osuint8 osqTcbRAM3 osAlarmActivated[1];
   #endif

   #if (osdNumberOfCounters > 0)

   osqROM0 osqROM1 const osqROM2 osAlarmIndexType osqROM3 oskAlarmHeapSize[0] = {
   };

   osqROM0 osqROM1 const osqROM2 osHeapType osqROM3 oskAlarmHeaps[0] = {
   };
   #endif

   #if (osdNumberOfAlarms > 0)
      osqTcbRAM1 volatile osqTcbRAM2 TickType osqTcbRAM3 osAlarmCycleTime[osdNumberOfAlarms];
   #else
      osqTcbRAM1 volatile osqTcbRAM2 TickType osqTcbRAM3 osAlarmCycleTime[1];
   #endif

/* Schedule Tables */ 
#if (osdNumberOfScheduleTables > 0)
osqROM0 osqROM1 const osqROM2 CounterType osqROM3 oskCounterOfST[osdNumberOfScheduleTables]={
};

osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskSTMaxAllowed[osdNumberOfScheduleTables]={
};

osqROM0 osqROM1 const osqROM2 osSTOffsetType osqROM3 oskScheduleTableInitialOffset[osdNumberOfScheduleTables] = {
   };

osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskAutostartScheduleTableOffset[osdNumberOfScheduleTables]={
   };

osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskPrecision[osdNumberOfScheduleTables]={
};

osqROM0 osqROM1 const osqROM2 osSTIndexType osqROM3 oskSTStartIndex[osdNumberOfScheduleTables]={
};

osqROM0 osqROM1 const osqROM2 osuint8 osqROM3 oskScheduleTableAutoStart[osdNumberOfScheduleTables] =
{
};
 osqROM0 osqROM1 const osqROM2 osuint8 osqROM3 oskScheduleTableAutoStartType[osdNumberOfScheduleTables] =
 {
 };
osqRAM0 osqRAM1 volatile osqRAM2 osSTIndexType           osqRAM3 osSTCurrentIndex[osdNumberOfScheduleTables];
osqRAM0 osqRAM1 volatile osqRAM2 ScheduleTableStatusType osqRAM3 osSTState[osdNumberOfScheduleTables];
osqRAM0 osqRAM1 volatile osqRAM2 ScheduleTableType       osqRAM3 osSTNextTable[osdNumberOfScheduleTables];

#if (osdNumberOfSTEntries > 0)
osqFunc1 osSTReactionType osqFunc2 osSTWorkActions(GlobalTimeTickType* diff, osSTIndexType CurrentEP)
{
   switch (CurrentEP)
   {
      /* MISRA RULE 14.1 VIOLATION: return is not
       * reachable but this is the only way for prevent a compiler warning (3201) */
      default:
         osSysErrAssertFailed(osdErrWSUnknownAction)
         return osdSTReact_Stop;  /* PRQA S 3201 */
   }
}
#endif /*(osdNumberOfSTEntries > 0)*/

#else
osqROM0 osqROM1 const osqROM2 CounterType    osqROM3 oskCounterOfST[1]                   = {0};
osqROM0 osqROM1 const osqROM2 TickType       osqROM3 oskSTMaxAllowed[1]                  = {0};
osqROM0 osqROM1 const osqROM2 osSTOffsetType osqROM3 oskScheduleTableInitialOffset[1]    = {0};
osqROM0 osqROM1 const osqROM2 TickType       osqROM3 oskAutostartScheduleTableOffset[1]  = {0};
osqROM0 osqROM1 const osqROM2 TickType       osqROM3 oskPrecision[1]                     = {0};
osqROM0 osqROM1 const osqROM2 osSTIndexType  osqROM3 oskSTStartIndex[1]                  = {0};
osqROM0 osqROM1 const osqROM2 osuint8        osqROM3 oskScheduleTableAutoStart[1]        = {0};
osqROM0 osqROM1 const osqROM2 osuint8        osqROM3 oskScheduleTableAutoStartType[1]    = {0};
osqRAM0 osqRAM1 volatile osqRAM2 osSTIndexType           osqRAM3 osSTCurrentIndex[1] = {0};
osqRAM0 osqRAM1 volatile osqRAM2 ScheduleTableStatusType osqRAM3 osSTState[1]        = {0};
osqRAM0 osqRAM1 volatile osqRAM2 ScheduleTableType       osqRAM3 osSTNextTable[1]    = {0};
#endif /* (osdNumberOfScheduleTables > 0) */

/* Counters */

/* Holds all counter values. Use this array only for write access.
For read access use osGetCurrentTime(). Size = #Counter */
osqTcbRAM1 volatile osqTcbRAM2 TickType osqTcbRAM3 osCounter[1];

/* Holds the maximum allowed value of all counters. Size = #Counter */
osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskCounterMaxAllowedValue[1]={ 0 };

/* Size = #Counter */
osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskCounterInternalMaximumValue[1]={ 0 };

/* Size = #Counter */
osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskCounterHalfrange[1]={ 0 };

/* Size = #Counter */
osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskCounterTicksPerBase[1]={400000};		//10ms		//{ 0 };

/* Defines the minimum time between two counter actions. Size = #Counter */
osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskCounterMinCycle[1]={ 0 };

/* The counters' reload values. Size = #Counter */
osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskCounterReloadValue[1]={ 0 };

/* The id of the core, this counter is assigned too. Size = #Counter */
osqROM0 osqROM1 const osqROM2 CoreIdType osqROM3 oskCounterCoreId[1]={ 0 };

/* The half allowed maximum value of high resolution counter. Size = #HiResCounter */
osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskCounterHiResMaxHardwareValueHalf[1]={ 0 };

/* Timer mask; n LSbs set, where n = timer bit width. Size = #HiResCounter */
osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskHiResTimerBitMask[1]={ 0 };

/* The half allowed maximum value of high resolution timer. Size = #HiResCounter */
osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskHWTimerSemiCount[1]={ 0 };

/* The minimum time between two high resolution timer interrupts. Size = #HiResCounter */
osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskMinTimeBetweenTimerIrqs[1]={ 0 };

/* Holds the last time of a high resolution timer interrupt. Size = #HiResCounter */
osqTcbRAM1 volatile osqTcbRAM2 TickType osqTcbRAM3 osLastHighResTimerIrq[1];

/* Holds the time of the next allowed high resolution interrupt. Size = #HiResCounter */
osqTcbRAM1 volatile osqTcbRAM2 TickType osqTcbRAM3 osNextAllowedTimerInt[1];
#pragma ghs section bss=".os_bss"
#pragma ghs section data=".os_data"
#pragma ghs section sbss=".os_sbss"
#pragma ghs section sdata=".os_sdata"
#pragma ghs section text=".os_text"
#pragma ghs section rodata=".os_rodata"
#pragma ghs section rosdata=".os_rosdata"

/* Start of invariant part */
#if ((CC == BCC2) || (CC == ECC2))
   #if (osdNumberOfAllTasks > 0)
      osqTcbRAM1 volatile osqTcbRAM2 osActivationCountType osqTcbRAM3 osTcbActivationCount[osdNumberOfAllTasks];
   #else
      osqTcbRAM1 volatile osqTcbRAM2 osActivationCountType osqTcbRAM3 osTcbActivationCount[1];
   #endif
#endif

osqTcbRAM1 osqTcbRAM2 osCtrlVarType osqTcbRAM3 osCtrlVarsCore0;
#if (osdNumberOfAllTasks > 0)
   osqTcbRAM1 volatile osqTcbRAM2 osTaskStateType osqTcbRAM3 osTcbTaskState[osdNumberOfAllTasks];
   #if osdORTIDebug
   osqTcbRAM1 osqTcbRAM2 osPrioType osqTcbRAM3 osTcbActualPrio[osdNumberOfAllTasks];
   osqTcbRAM1 osqTcbRAM2 osuint8 osqTcbRAM3 osTcbORTIServiceId[osdNumberOfAllTasks];
   #endif
   #if STATUS_LEVEL == EXTENDED_STATUS
    #if (osdNumberOfInternalResources > 0) || (osdNumberOfInterruptResources > 0)
     osqTcbRAM1 osqTcbRAM2 osuint8 osqTcbRAM3 osTcbResourceCounter[osdNumberOfAllTasks];
    #else
     #if osdLib
      osqTcbRAM1 osqTcbRAM2 osuint8 osqTcbRAM3 osTcbResourceCounter[osdNumberOfAllTasks];
     #endif
    #endif
   #endif
#else
   osqTcbRAM1 volatile osqTcbRAM2 osTaskStateType osqTcbRAM3 osTcbTaskState[1];
   #if osdORTIDebug
   osqTcbRAM1 osqTcbRAM2 osPrioType osqTcbRAM3 osTcbActualPrio[1];
   osqTcbRAM1 osqTcbRAM2 osuint8 osqTcbRAM3 osTcbORTIServiceId[1];
   #endif
   #if STATUS_LEVEL == EXTENDED_STATUS
   #if (osdNumberOfInternalResources > 0) || (osdNumberOfInterruptResources > 0)
   osqTcbRAM1 osqTcbRAM2 osuint8 osqTcbRAM3 osTcbResourceCounter[1];
    #else
     #if osdLib
      osqTcbRAM1 osqTcbRAM2 osuint8 osqTcbRAM3 osTcbResourceCounter[1];
     #endif
    #endif
   #endif
#endif




   osqTcbRAM1 volatile osqTcbRAM2 EventMaskType osqTcbRAM3 osTcbWaitEventMask[osdNumberOfExtendedTasks];

#if ((osdSC == SC3) || (osdSC == SC4))
   osqTcbRAM1 volatile osqTcbRAM2 ApplicationStateType osqTcbRAM3 osApplicationState [osdNumberOfApplications];
#endif

#if (osdNumberOfExtendedTasks > 0) || osdLib
   #if (osdNumberOfExtendedTasks == 0) && osdLib
   osqTcbRAM1 volatile osqTcbRAM2 EventMaskType osqTcbRAM3 osTcbSetEventMask[1];
   #else
   osqTcbRAM1 volatile osqTcbRAM2 EventMaskType osqTcbRAM3 osTcbSetEventMask[osdNumberOfExtendedTasks];
   #endif
#endif

#if (osdNumberOfSemaphores > 0)
   osqTcbRAM1 osqTcbRAM2 osuint8 osqTcbRAM3 osSemaphoreState[osdNumberOfSemaphores];
   #if (osdNumberOfExtendedTasks == 0) && osdLib
   osqTcbRAM1 volatile osqTcbRAM2 osSemaphoreType osqTcbRAM3 osTcbWaitForSemaphore[1];
   #else
   osqTcbRAM1 volatile osqTcbRAM2 osSemaphoreType osqTcbRAM3 osTcbWaitForSemaphore[osdNumberOfExtendedTasks];
   #endif
   #if (osdKillTaskIsrPossible || (osdSC== SC3) || (osdSC== SC4))
      osqTcbRAM1 volatile osqTcbRAM2 TaskType osqTcbRAM3 osSemaOwner[osdNumberOfSemaphores];
   #endif
#endif

#if osdLib
   osqROM0 osqROM1 const osqROM2 osRTSizeType    osqROM3 oskRTSize= osdRTSize;
   osqROM0 osqROM1 const osqROM2 osAppModeIndexType osqROM3 oskNumberOfAppModes=   osdNumberOfAppModes;
   osqROM0 osqROM1 const osqROM2 osTaskIndexType osqROM3 oskNumberOfAllTasks=      osdNumberOfAllTasks;
   osqROM0 osqROM1 const osqROM2 osTaskIndexType osqROM3 oskNumberOfExtendedTasks= osdNumberOfExtendedTasks;
   osqROM0 osqROM1 const osqROM2 osPrioType      osqROM3 oskNumberOfPriorities=    osdNumberOfPriorities;

   osqROM0 osqROM1 const osqROM2 osResourceIndexType osqROM3 oskNumberOfAllResources= osdNumberOfAllResources;
   osqROM0 osqROM1 const osqROM2 osResourceIndexType osqROM3 oskNumberOfTaskResources= osdNumberOfTaskResources;
   osqROM0 osqROM1 const osqROM2 osResourceIndexType osqROM3 oskNumberOfInterruptResources= osdNumberOfInterruptResources;
   osqROM0 osqROM1 const osqROM2 osResourceIndexType osqROM3 oskNumberOfInternalResources= osdNumberOfInternalResources;

   osqROM0 osqROM1 const osqROM2 osAlarmIndexType osqROM3 oskNumberOfAlarms=       osdNumberOfAlarms;
   
   osqROM0 osqROM1 const osqROM2 ScheduleTableType osqROM3 oskNumberOfScheduleTables=    osdNumberOfScheduleTables;
   osqROM0 osqROM1 const osqROM2 osSemaphoreType osqROM3 oskNumberOfSemaphores=          osdNumberOfSemaphores;
   osqROM0 osqROM1 const osqROM2 CounterType osqROM3 oskSystemTimer=                     SystemTimer;
   osqROM0 osqROM1 const osqROM2 CounterType osqROM3 oskNumberOfCounters=                osdNumberOfCounters;
   
   osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskMaxAllowedValue=    (TickType)OSMAXALLOWEDVALUE;
   osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskMinCycle=                     OSMINCYCLE;
   osqROM0 osqROM1 const osqROM2 TickType osqROM3 oskTicksPerBase=                 OSTICKSPERBASE;

#endif
/* End of invariant part */
osqROM0 osqROM1 const osqROM2 osTaskFlagType osqROM3 oskTcbTaskFlags[osdNumberOfAllTasks] = {
 0,
 0,
 0,
 0,
 0,
 0,
 0,
};

osqROM0 osqROM1 const osqROM2 osPrioFlagType osqROM3 oskTcbReadyPrioMask[osdNumberOfAllTasks] = {
   0x40000000UL,
   0x20000000UL,
   0x10000000UL,
   0x08000000UL,
   0x04000000UL,
   0x02000000UL,
   0x80000000UL,
};

#if (osdRTSize > 1)
osqROM0 osqROM1 const osqROM2 osPrioOffsetType osqROM3 oskTcbReadyPrioOffset[osdNumberOfAllTasks] = {
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
   0x00,
};
#endif /* (osdRTSize > 1) */
osqROM0 osqROM1 const osqROM2 osPrioType osqROM3 oskTcbHomePrio[osdNumberOfAllTasks] = {
   1,
   2,
   3,
   4,
   5,
   6,
   0,
};

#if (CC == BCC2) || (CC == ECC2)
osqROM0 osqROM1 const osqROM2 osActivationCountType osqROM3 oskTcbAllowedActivations[osdNumberOfAllTasks] = {
   1,
   1,
   1,
   1,
   1,
   1,
   1,
};
#endif /* (CC == BCC2) || (CC == ECC2) */

#if (osdKillTaskIsrPossible || (osdSC== SC3) || (osdSC== SC4))
#if (osdNumberOfAllTasks > 0)
   osqTcbRAM1 osqTcbRAM2 osResourceIndexType osqTcbRAM3 osTcbLockedResource[osdNumberOfAllTasks];
#else
   osqTcbRAM1 osqTcbRAM2 osResourceIndexType osqTcbRAM3 osTcbLockedResource[1];
#endif

#endif /* (osdKillTaskIsrPossible || (osdSC== SC3) || (osdSC== SC4)) */
#if (osdNumberOfAlarms > 0)
 osqROM0 osqROM1 const osqROM2 osuint8 osqROM3 oskAlarmAutoStart[osdNumberOfAlarms] =
 {
 };
#endif

#if (osdNumberOfAlarms > 0)
 osqROM0 osqROM1 const osqROM2 osuint8 osqROM3 oskAlarmAutoStartType[osdNumberOfAlarms] =
 {
 };
#endif

#if (osdNumberOfAllTasks > 0)
 osqROM0 osqROM1 const osqROM2 osuint8 osqROM3 oskTcbAutoStart[osdNumberOfAllTasks] =
 {
    0x00, /* SystemSwitchHigh*/
    0x00, /* FastCyclic*/
    0x00, /* EventTask*/
    0x00, /* SlowCyclic*/
    0x00, /* SlowJob*/
    0x00, /* SystemSwitchLow*/
    0x01, /* ResetTask*/
 };
#endif

/* Resources */

#if ((!defined(osdGetResourceNotUsed)) || (!defined(osdReleaseResourceNotUsed)))
#if (STATUS_LEVEL == EXTENDED_STATUS) && osdEnableAssertions
osqROM0 osqROM1 const osqROM2 osResAccessMaskType osqROM3 oskResAccessMask[1][1]=
{
   { 0U } /* default */
};

#endif /* (STATUS_LEVEL == EXTENDED_STATUS) && osdEnableAssertions */

osqROM0 osqROM1 const osqROM2 osPrioType osqROM3 oskResCeilingPrio[1]=
{
   0U
};

#endif /* ((!defined(osdGetResourceNotUsed)) || (!defined(osdReleaseResourceNotUsed))) */

#if (osdNumberOfAllTasks>0)
#if ((osdNumberOfInternalResources > 0)||(osdLib==1))
osqROM0 osqROM1 const osqROM2 osPrioType osqROM3 oskResInternalCeilingPrio[osdNumberOfAllTasks]=
{
   (osPrioType) 0,
   (osPrioType) 0,
   (osPrioType) 0,
   (osPrioType) 0,
   (osPrioType) 0,
   (osPrioType) 0,
   (osPrioType) 0,
};

osqROM0 osqROM1 const osqROM2 osPrioFlagType osqROM3 oskResInternalCeilingPrioMask[osdNumberOfAllTasks]=
{
   0,
   0,
   0,
   0,
   0,
   0,
   0,
};

 #if ((osdRTSize > 1)||(osdLib==1))
osqROM0 osqROM1 const osqROM2 osPrioOffsetType osqROM3 oskResInternalCeilingPrioOffset[osdNumberOfAllTasks]=
{
   0,
   0,
   0,
   0,
   0,
   0,
   0,
};

#endif
#endif

#else
osqROM0 osqROM1 const osqROM2 osPrioType osqROM3 oskResInternalCeilingPrio[1]={0};
osqROM0 osqROM1 const osqROM2 osPrioFlagType osqROM3 oskResInternalCeilingPrioMask[1]={0};
osqROM0 osqROM1 const osqROM2 osPrioOffsetType osqROM3 oskResInternalCeilingPrioOffset[1]={0};
#endif
#if (osdKillTaskIsrPossible || (osdSC== SC3) || (osdSC== SC4))
#if (osdNumberOfAllResources > 0)
   osqTcbRAM1 osqTcbRAM2 osResourceIndexType osqTcbRAM3 osResNextLockedResource[osdNumberOfAllResources];
#else
   osqTcbRAM1 osqTcbRAM2 osResourceIndexType osqTcbRAM3 osResNextLockedResource[1];
#endif
#endif

/* Alarms */

/* Applications */

#if (osdNumberOfApplications > 0)

/* Owner application for each task */
/* Owner application for each ISR */
/* Owner application for each resource */
/* Owner application for each alarm */
/* MISRA RULE 8.10 VIOLATION: In some configurations this array is only referenced in this
 * unit, adding code to make it static in those cases would increase code complexity too much.
 */
osqROM0 osqROM1 const osqROM2 ApplicationType osqROM3 oskAlarmToAppl[1]={0}; /* TR:SPMF20:0009 */  /* PRQA S 1504 */

/* Owner application for each counter */
/* MISRA RULE 8.10 VIOLATION: In some configurations this array is only referenced in this
 * unit, adding code to make it static in those cases would increase code complexity too much.
 */
osqROM0 osqROM1 const osqROM2 ApplicationType osqROM3 oskCounterToAppl[1] = {0}; /* PRQA S 1504 */

/* Owner application for each schedule table */
/* MISRA RULE 8.10 VIOLATION: In some configurations this array is only referenced in this
 * unit, adding code to make it static in those cases would increase code complexity too much.
 */
osqROM0 osqROM1 const osqROM2 ApplicationType osqROM3 oskScheduleTableToAppl[1] = {0}; /* PRQA S 1504 */

#endif /* osdNumberOfApplications > 0 */

#if (osdKillTaskIsrPossible || (osdSC== SC3) || (osdSC== SC4))
#if (osdNumberOfCat2ISRs > 0)
   osqTcbRAM1 osqTcbRAM2 osResourceIndexType osqTcbRAM3 osIcbLockedResource[osdNumberOfCat2ISRs];
#else
   osqTcbRAM1 osqTcbRAM2 osResourceIndexType osqTcbRAM3 osIcbLockedResource[1];
#endif
#endif


/* END OF D:\AutoSar generated code\tcb.c */

#pragma ghs section bss=default
#pragma ghs section data=default
#pragma ghs section sbss=default
#pragma ghs section sdata=default
#pragma ghs section text=default
#pragma ghs section rodata=default
#pragma ghs section rosdata=default

#pragma ghs section bss=default
#pragma ghs section data=default
#pragma ghs section sbss=default
#pragma ghs section sdata=default
#pragma ghs section text=default
#pragma ghs section rodata=default
#pragma ghs section rosdata=default

